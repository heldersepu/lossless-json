{"version":3,"file":"lossless-json.js","sources":["../lib/config.js","../lib/LosslessNumber.js","../lib/revive.js","../lib/pointer.js","../lib/parse.js","../lib/stringify.js"],"sourcesContent":["\r\nlet circularRefs = true;\r\n\r\n/**\r\n * Get and/or set configuration options\r\n * @param {{circularRefs: boolean}} [options]\r\n * @retrun {{circularRefs: boolean}}\r\n */\r\nexport function config (options) {\r\n  if (options) {\r\n    if (options.circularRefs != undefined) {\r\n      circularRefs = (options.circularRefs === true);\r\n    }\r\n  }\r\n\r\n  return { circularRefs }\r\n}\r\n","'use strict';\r\n\r\n/**\r\n * A lossless number. Stores it's value as string\r\n * @param {string | number} value\r\n * @constructor\r\n */\r\nexport class LosslessNumber {\r\n  constructor (value) {\r\n    // value as string\r\n    this.value = valueToString(value);\r\n\r\n    // type information\r\n    this.type = 'LosslessNumber';\r\n    this.isLosslessNumber = true;\r\n  }\r\n\r\n  /**\r\n   * Get the value of the LosslessNumber as number.\r\n   * Will throw an error when this conversion would result in a truncation\r\n   * of the number.\r\n   * @return {Number}\r\n   */\r\n  valueOf () {\r\n    let number = parseFloat(this.value);\r\n    let digits = getDigits(this.value);\r\n\r\n    // throw an error when the numeric value will lose information\r\n    if (digits.length > 15) {\r\n      throw new Error('Cannot convert to number: ' +\r\n          'number would be truncated (value: ' + this.value + ')');\r\n    }\r\n    if (!isFinite(number)) {\r\n      throw new Error('Cannot convert to number: number would overflow (value: ' + this.value + ')');\r\n    }\r\n    if (Math.abs(number) < Number.MIN_VALUE && !containsOnlyZeros(digits)) {\r\n      throw new Error('Cannot convert to number: number would underflow (value: ' + this.value + ')');\r\n    }\r\n\r\n    return number;\r\n  }\r\n\r\n  /**\r\n   * Get the value of the LosslessNumber as string.\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    return this.value;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Convert input value to a string\r\n * If value is no number or string, the valueOf() of the object will be used.\r\n * @param {number | string} value\r\n * @return {string}\r\n */\r\nexport function valueToString (value) {\r\n  if (typeof value === 'string') {\r\n    if (!isValidNumber(value)) {\r\n      throw new Error('Invalid number (value: \"' + value +'\")');\r\n    }\r\n\r\n    return value;\r\n  }\r\n  else if (typeof value === 'number') {\r\n    // validate number\r\n    if (getDigits(value + '').length > 15) {\r\n      throw new Error('Invalid number: contains more than 15 digits (value: ' + value + ')');\r\n    }\r\n    if (isNaN(value)) {\r\n      throw new Error('Invalid number: NaN');\r\n    }\r\n    if (!isFinite(value)) {\r\n      throw new Error('Invalid number: Infinity');\r\n    }\r\n\r\n    return value + '';\r\n  }\r\n  else {\r\n    return valueToString(value && value.valueOf());\r\n  }\r\n}\r\n\r\n/**\r\n * Parse a string into a number. When the value can be represented in a number,\r\n * the function returns a number. Else, the function returns a LosslessNumber\r\n * @param {string} value\r\n * @returns {LosslessNumber | number} Returns a number when the value fits\r\n *                                    in a regular number, else returns a\r\n *                                    LosslessNumber.\r\n */\r\nexport function createNumber (value) {\r\n  let digits = getDigits(value);\r\n\r\n  if (digits.length > 15) {\r\n    // would truncate digits\r\n    return new LosslessNumber(value);\r\n  }\r\n\r\n  let number = parseFloat(value);\r\n  if (!isFinite(number)) {\r\n    // overflow, finite or NaN\r\n    return new LosslessNumber(value);\r\n  }\r\n  else if (Math.abs(number) < Number.MIN_VALUE && !containsOnlyZeros(digits)) {\r\n    // underflow\r\n    return new LosslessNumber(value);\r\n  }\r\n  else {\r\n    return number;\r\n  }\r\n}\r\n\r\n/**\r\n * Count the number of significant digits of a number.\r\n *\r\n * For example:\r\n *   '2.34' returns '234'\r\n *   '-77' returns '77'\r\n *   '0.0034' returns '34'\r\n *   '120.5e+30' returns '1205'\r\n *\r\n * @param {number | string} value\r\n * @return {string} Returns the significant digits\r\n */\r\nexport function getDigits (value) {\r\n  let _value = (typeof value !== 'string') ? (value + '') : value;\r\n\r\n  return _value\r\n      .replace(/^-/, '')            // remove sign\r\n      .replace(/e.*$/, '')          // remove exponential notation\r\n      .replace( /^0\\.?0*|\\./, '');  // remove decimal point and leading zeros\r\n}\r\n\r\n/**\r\n * Test whether a string contains only zeros or is empty\r\n * @param {string} text\r\n * @return {boolean}\r\n */\r\nexport function containsOnlyZeros (text) {\r\n  return /^0*$/.test(text);\r\n}\r\n\r\n/**\r\n * Test whether a string contains a valid number\r\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\r\n * @param {string} value\r\n * @return {boolean}\r\n */\r\nexport function isValidNumber(value) {\r\n  return /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/.test(value);\r\n}\r\n","/**\r\n * Revive a json object.\r\n * Applies the reviver function recursively on all values in the JSON object.\r\n * @param {*} json   A JSON Object, Array, or value\r\n * @param {function (key: string, value: *)} reviver\r\n *              A reviver function invoked with arguments `key` and `value`,\r\n *              which must return a replacement value. The function context\r\n *              (`this`) is the Object or Array that contains the currently\r\n *              handled value.\r\n * @return {*}\r\n */\r\nexport function revive (json, reviver) {\r\n  return reviveValue({'': json}, '', json, reviver);\r\n}\r\n\r\n/**\r\n * Revive a value\r\n * @param {Object | Array} context\r\n * @param {string} key\r\n * @param {*} value\r\n * @param {function(key: string, value: *)} reviver\r\n * @return {*}\r\n */\r\nfunction reviveValue (context, key, value, reviver) {\r\n  if (Array.isArray(value)) {\r\n    return reviver.call(context, key, reviveArray(value, reviver));\r\n  }\r\n  else if (value && typeof value === 'object' && !value.isLosslessNumber) {\r\n    // note the special case for LosslessNumber,\r\n    // we don't want to iterate over the internals of a LosslessNumber\r\n    return reviver.call(context, key, reviveObject(value, reviver))\r\n  }\r\n  else {\r\n    return reviver.call(context, key, value)\r\n  }\r\n}\r\n\r\n/**\r\n * Revive the properties of an object\r\n * @param {Object} object\r\n * @param {function} reviver\r\n * @return {Object}\r\n */\r\nfunction reviveObject (object, reviver) {\r\n  let revived = {};\r\n\r\n  for (let key in object) {\r\n    if (object.hasOwnProperty(key)) {\r\n      revived[key] = reviveValue(object, key, object[key], reviver);\r\n    }\r\n  }\r\n\r\n  return revived;\r\n}\r\n\r\n/**\r\n * Revive the properties of an Array\r\n * @param {Array} array\r\n * @param {function} reviver\r\n * @return {Array}\r\n */\r\nfunction reviveArray (array, reviver) {\r\n  let revived = [];\r\n\r\n  for (let i = 0; i < array.length; i++) {\r\n    revived[i] = reviveValue(array, i + '', array[i], reviver);\r\n  }\r\n\r\n  return revived;\r\n}\r\n","// JavaScript Object Notation (JSON) Pointer\r\n// https://tools.ietf.org/html/rfc6901\r\n\r\n/**\r\n * Escape a JSON Pointer\r\n *\r\n * @param {string} str\r\n * @returns {string}\r\n */\r\nexport function escape (str) {\r\n  return encodeURIComponent(str\r\n      .replace(/\\//g, '~1')\r\n      .replace(/~/g, '~0'));\r\n}\r\n\r\n/**\r\n * Unescape a JSON Pointer\r\n *\r\n * @param {string} str\r\n * @returns {string}\r\n */\r\nexport function unescape (str) {\r\n  return decodeURIComponent(str)\r\n      .replace(/~1/g, '/')\r\n      .replace(/~0/g, '~');\r\n}\r\n\r\n/**\r\n * Stringify an array of keys as a JSON Pointer URI fragment\r\n *\r\n * Example:\r\n *\r\n *     stringify(['foo', 'bar'])     // returns '#/foo/bar'\r\n *     stringify(['foo bar', 'baz']) // returns '#/foo%20bar/baz'\r\n *\r\n * @param {Array.<string>} array\r\n * @returns {string}\r\n */\r\nexport function stringify(array) {\r\n  return '#/' + array.map(escape).join('/');\r\n}\r\n\r\n/**\r\n * Parse a JSON Pointer URI fragment\r\n * @param {string} pointer\r\n * @return {Array.<string>}\r\n */\r\nexport function parse(pointer) {\r\n  let array = pointer.split('/').map(unescape);\r\n\r\n  // remove the hash\r\n  let hash = array.shift();\r\n  if (hash !== '#') {\r\n    throw SyntaxError('Cannot parse JSON Pointer: no valid URI fragment');\r\n  }\r\n\r\n  // remove last empty entry\r\n  if (array[array.length - 1] === '') {\r\n    array.pop();\r\n  }\r\n\r\n  return array;\r\n}\r\n","'use strict';\r\n\r\nimport { config } from './config';\r\nimport { LosslessNumber } from './LosslessNumber';\r\nimport { revive } from './revive';\r\nimport { parse as parsePointer } from './pointer';\r\n\r\n// token types enumeration\r\nconst TOKENTYPE = {\r\n  NULL: 0,\r\n  DELIMITER: 1,\r\n  NUMBER: 2,\r\n  STRING: 3,\r\n  SYMBOL: 4,\r\n  UNKNOWN: 5\r\n};\r\n\r\n// map with all delimiters\r\nconst DELIMITERS = {\r\n  '': true,\r\n  '{': true,\r\n  '}': true,\r\n  '[': true,\r\n  ']': true,\r\n  ':': true,\r\n  ',': true\r\n};\r\n\r\n// map with all escape characters\r\nconst ESCAPE_CHARACTERS = {\r\n  '\\\"': '\\\"',\r\n  '\\\\': '\\\\',\r\n  '/': '/',\r\n  'b': '\\b',\r\n  'f': '\\f',\r\n  'n': '\\n',\r\n  'r': '\\r',\r\n  't': '\\t'\r\n  // \\u is handled by getToken()\r\n};\r\n\r\nlet jsonText = '';                // current json text\r\nlet index = 0;                    // current index in text\r\nlet c = '';                       // current token character in text\r\nlet token = '';                   // current token\r\nlet tokenType = TOKENTYPE.NULL;   // type of current token\r\n\r\n// Keep track of the stack to handle circular references\r\n// https://github.com/manuelstofer/json-pointer/blob/master/index.js\r\n// stack of currently stringified objects\r\nlet path = [];  // keys on the current stack\r\nlet stack = []; // objects (Object or Array) on the current stack\r\n\r\n/**\r\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\r\n * the value produced by parsing.\r\n *\r\n * @param {string} text\r\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\r\n *\r\n * @param {function(key: string, value: *)} [reviver]\r\n * If a function, prescribes how the value originally produced by parsing is\r\n * transformed, before being returned.\r\n *\r\n * @returns Returns the Object corresponding to the given JSON text.\r\n *\r\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\r\n */\r\nexport function parse (text, reviver) {\r\n  // initialize\r\n  jsonText = text;\r\n  index = 0;\r\n  c = jsonText.charAt(0);\r\n  token = '';\r\n  tokenType = TOKENTYPE.NULL;\r\n\r\n  // clear stack\r\n  stack = [];\r\n  path = [];\r\n\r\n  // get first token\r\n  getToken();\r\n\r\n  // parse everything\r\n  let json = parseObject();\r\n\r\n  if (token != '') {\r\n    throw createSyntaxError('Unexpected characters');\r\n  }\r\n\r\n  return reviver ? revive(json, reviver) : json;\r\n}\r\n\r\n/**\r\n * Get the next character from the expression.\r\n * The character is stored into the char c. If the end of the expression is\r\n * reached, the function puts an empty string in c.\r\n * @private\r\n */\r\nfunction next() {\r\n  index++;\r\n  c = jsonText.charAt(index);\r\n}\r\n\r\n/**\r\n * Get next token in the current text.\r\n * The token and token type are available as token and tokenType\r\n * @private\r\n */\r\nfunction getToken() {\r\n  tokenType = TOKENTYPE.NULL;\r\n  token = '';\r\n\r\n  // skip over whitespaces: space, tab, newline, and carriage return\r\n  while (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') {\r\n    next();\r\n  }\r\n\r\n  // check for delimiters\r\n  if (DELIMITERS[c]) {\r\n    tokenType = TOKENTYPE.DELIMITER;\r\n    token = c;\r\n    next();\r\n    return;\r\n  }\r\n\r\n  // check for a number\r\n  if (isDigit(c) || c == '-') {\r\n    tokenType = TOKENTYPE.NUMBER;\r\n\r\n    if (c == '-') {\r\n      token += c;\r\n      next();\r\n\r\n      if (!isDigit(c)) {\r\n        throw createSyntaxError('Invalid number, digit expected', index);\r\n      }\r\n    }\r\n    else if (c == '0') {\r\n      token += c;\r\n      next();\r\n    }\r\n    else {\r\n      // digit 1-9, nothing extra to do\r\n    }\r\n\r\n    while (isDigit(c)) {\r\n      token += c;\r\n      next();\r\n    }\r\n\r\n    if (c == '.') {\r\n      token += c;\r\n      next();\r\n\r\n      if (!isDigit(c)) {\r\n        throw createSyntaxError('Invalid number, digit expected', index);\r\n      }\r\n\r\n      while (isDigit(c)) {\r\n        token += c;\r\n        next();\r\n      }\r\n    }\r\n\r\n    if (c == 'e' || c == 'E') {\r\n      token += c;\r\n      next();\r\n\r\n      if (c == '+' || c == '-') {\r\n        token += c;\r\n        next();\r\n      }\r\n\r\n      if (!isDigit(c)) {\r\n        throw createSyntaxError('Invalid number, digit expected', index);\r\n      }\r\n\r\n      while (isDigit(c)) {\r\n        token += c;\r\n        next();\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  // check for a string\r\n  if (c == '\"') {\r\n    tokenType = TOKENTYPE.STRING;\r\n    next();\r\n\r\n    while (c != '' && c != '\"') {\r\n\r\n      if (c == '\\\\') {\r\n        // handle escape characters\r\n        next();\r\n\r\n        let unescaped = ESCAPE_CHARACTERS[c];\r\n        if (unescaped !== undefined) {\r\n          token += unescaped;\r\n          next();\r\n        }\r\n        else if (c == 'u') {\r\n          // parse escaped unicode character, like '\\\\u260E'\r\n          next();\r\n\r\n          let hex = '';\r\n          for (let u = 0; u < 4; u++) {\r\n            if (!isHex(c)) {\r\n              throw createSyntaxError('Invalid unicode character');\r\n            }\r\n            hex += c;\r\n            next();\r\n          }\r\n\r\n          token += String.fromCharCode(parseInt(hex, 16));\r\n        }\r\n        else {\r\n          throw createSyntaxError('Invalid escape character \"\\\\' + c + '\"', index);\r\n        }\r\n      }\r\n      else {\r\n        // a regular character\r\n        token += c;\r\n        next();\r\n      }\r\n    }\r\n\r\n    if (c != '\"') {\r\n      throw createSyntaxError('End of string expected');\r\n    }\r\n    next();\r\n\r\n    return;\r\n  }\r\n\r\n  // check for symbols (true, false, null)\r\n  if (isAlpha(c)) {\r\n    tokenType = TOKENTYPE.SYMBOL;\r\n\r\n    while (isAlpha(c)) {\r\n      token += c;\r\n      next();\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  // something unknown is found, wrong characters -> a syntax error\r\n  tokenType = TOKENTYPE.UNKNOWN;\r\n  while (c != '') {\r\n    token += c;\r\n    next();\r\n  }\r\n  throw createSyntaxError('Syntax error in part \"' + token + '\"');\r\n}\r\n\r\n/**\r\n * Check if the given character contains an alpha character, a-z, A-Z, _\r\n * @param {string} c   a string with one character\r\n * @return {boolean}\r\n */\r\nfunction isAlpha (c) {\r\n  return /^[a-zA-Z_]/.test(c);\r\n}\r\n\r\n/**\r\n * Check if the given character contains a hexadecimal character 0-9, a-f, A-F\r\n * @param {string} c   a string with one character\r\n * @return {boolean}\r\n */\r\nfunction isHex (c) {\r\n  return /^[0-9a-fA-F]/.test(c);\r\n}\r\n\r\n/**\r\n * checks if the given char c is a digit\r\n * @param {string} c   a string with one character\r\n * @return {boolean}\r\n * @private\r\n */\r\nfunction isDigit (c) {\r\n  return (c >= '0' && c <= '9');\r\n}\r\n\r\n/**\r\n * Create an error\r\n * @param {string} message\r\n * @param {number} [c]  Optional index (character position) where the\r\n *                      error happened. If not provided, the start of\r\n *                      the current token is taken\r\n * @return {SyntaxError} instantiated error\r\n * @private\r\n */\r\nfunction createSyntaxError (message, c) {\r\n  if (c === undefined) {\r\n    c = index - token.length;\r\n  }\r\n  let error = new SyntaxError(message + ' (char ' + c + ')');\r\n  error['char'] = c;\r\n\r\n  return error;\r\n}\r\n\r\n/**\r\n * Parse an object like '{\"key\": \"value\"}'\r\n * @return {*}\r\n */\r\nfunction parseObject () {\r\n  if (token == '{') {\r\n    getToken();\r\n\r\n    let key;\r\n    let object = {};\r\n\r\n    if (token == '}') {\r\n      // empty object\r\n      getToken();\r\n      return object;\r\n    }\r\n\r\n    // add this object to the stack\r\n    const stackIndex = stack.length;\r\n    stack[stackIndex] = object;\r\n\r\n    while (true) {\r\n      // parse key\r\n      if (tokenType != TOKENTYPE.STRING) {\r\n        throw createSyntaxError('Object key expected');\r\n      }\r\n      key = token;\r\n      getToken();\r\n\r\n      // parse key/value separator\r\n      if (token != ':') {\r\n        throw createSyntaxError('Colon expected');\r\n      }\r\n      getToken();\r\n\r\n      // parse value\r\n      path[stackIndex] = key;\r\n      object[key] = parseObject();\r\n\r\n      // parse key/value pair separator\r\n      if (token != ',') {\r\n        break;\r\n      }\r\n      getToken();\r\n    }\r\n\r\n    if (token != '}') {\r\n      throw createSyntaxError('Comma or end of object \"}\" expected');\r\n    }\r\n    getToken();\r\n\r\n    // check whether this is a circular reference\r\n    if (isCircular(object)) {\r\n      return parseCircular(object);\r\n    }\r\n\r\n    // remove current entry from the stack\r\n    stack.length = stackIndex;\r\n    path.length = stackIndex;\r\n\r\n    return object;\r\n  }\r\n\r\n  return parseArray();\r\n}\r\n\r\n/**\r\n * Parse an object like '[\"item1\", \"item2\", ...]'\r\n * @return {*}\r\n */\r\nfunction parseArray () {\r\n  if (token == '[') {\r\n    getToken();\r\n\r\n    let array = [];\r\n\r\n    if (token == ']') {\r\n      // empty array\r\n      getToken();\r\n      return array;\r\n    }\r\n\r\n    // add this array to the stack\r\n    const stackIndex = stack.length;\r\n    stack[stackIndex] = array;\r\n\r\n    while (true) {\r\n      // parse item\r\n      path[stackIndex] = array.length + '';\r\n      array.push(parseObject());\r\n\r\n      // parse item separator\r\n      if (token != ',') {\r\n        break;\r\n      }\r\n      getToken();\r\n    }\r\n\r\n    if (token != ']') {\r\n      throw createSyntaxError('Comma or end of array \"]\" expected');\r\n    }\r\n    getToken();\r\n\r\n    // remove current entry from the stack\r\n    stack.length = stackIndex;\r\n    path.length = stackIndex;\r\n\r\n    return array;\r\n  }\r\n\r\n  return parseString();\r\n}\r\n\r\n/**\r\n * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\r\n * @return {*}\r\n */\r\nfunction parseString () {\r\n  if (tokenType == TOKENTYPE.STRING) {\r\n    let str = token;\r\n    getToken();\r\n    return str;\r\n  }\r\n\r\n  return parseNumber();\r\n}\r\n\r\n/**\r\n * Parse a number. The number will be parsed as a LosslessNumber.\r\n * @return {*}\r\n */\r\nfunction parseNumber () {\r\n  if (tokenType == TOKENTYPE.NUMBER) {\r\n    let number = new LosslessNumber(token);\r\n    getToken();\r\n    return number;\r\n  }\r\n\r\n  return parseSymbol();\r\n}\r\n\r\n/**\r\n * Parse constants true, false, null\r\n * @return {boolean | null}\r\n */\r\nfunction parseSymbol () {\r\n  if (tokenType == TOKENTYPE.SYMBOL) {\r\n    if (token === 'true') {\r\n      getToken();\r\n      return true;\r\n    }\r\n    if (token === 'false') {\r\n      getToken();\r\n      return false;\r\n    }\r\n    if (token === 'null') {\r\n      getToken();\r\n      return null;\r\n    }\r\n\r\n    throw createSyntaxError('Unknown symbol \"' + token + '\"');\r\n  }\r\n\r\n  return parseEnd();\r\n}\r\n\r\n/**\r\n * Evaluated when the expression is not yet ended but expected to end\r\n */\r\nfunction parseEnd () {\r\n  if (token == '') {\r\n    // syntax error or unexpected end of expression\r\n    throw createSyntaxError('Unexpected end of json string');\r\n  } else {\r\n    throw createSyntaxError('Value expected');\r\n  }\r\n}\r\n\r\n/**\r\n * Test whether an object is a circular reference, like {$ref: '#/foo/bar'}\r\n * @param {Object} object\r\n * @return {boolean}\r\n */\r\nfunction isCircular (object) {\r\n  return typeof object.$ref === 'string' && Object.keys(object).length === 1;\r\n}\r\n\r\n/**\r\n * Resolve a circular reference.\r\n * Throws an error if the path cannot be resolved\r\n * @param {Object} object    An object with a JSON Pointer URI fragment\r\n *                           like {$ref: '#/foo/bar'}\r\n * @return {Object | Array}\r\n */\r\nfunction parseCircular(object) {\r\n  // if circular references are disabled, just return the refs object\r\n  if (!config().circularRefs) {\r\n    return object;\r\n  }\r\n\r\n  let pointerPath = parsePointer(object.$ref);\r\n\r\n  // validate whether the path corresponds with current stack\r\n  for (let i = 0; i < pointerPath.length; i++) {\r\n    if (pointerPath[i] !== path[i]) {\r\n      throw new Error('Invalid circular reference \"' +  object.$ref + '\"');\r\n    }\r\n  }\r\n\r\n  return stack[pointerPath.length];\r\n}\r\n","'use strict';\r\n\r\nimport { config } from './config'\r\nimport { stringify as stringifyPointer } from './pointer';\r\n\r\n// map with control characters to be escaped\r\nconst CONTROL_CHARACTERS = {\r\n  '\"': '\\\\\"',\r\n  '\\\\': '\\\\\\\\',\r\n  '\\b': '\\\\b',\r\n  '\\f': '\\\\f',\r\n  '\\n': '\\\\n',\r\n  '\\r': '\\\\r',\r\n  '\\t': '\\\\t'\r\n};\r\n\r\n// Keep track of the stack to handle circular references\r\n// https://github.com/manuelstofer/json-pointer/blob/master/index.js\r\n// stack of currently stringified objects\r\nlet path = [];  // keys on the current stack\r\nlet stack = []; // objects (Object or Array) on the current stack\r\n\r\n/**\r\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\r\n * optionally replacing values if a replacer function is specified, or\r\n * optionally including only the specified properties if a replacer array is specified.\r\n *\r\n * @param {*} value\r\n * The value to convert to a JSON string.\r\n *\r\n * @param {function(key: string, value: *) | Array.<string | number>} [replacer]\r\n * A function that alters the behavior of the stringification process,\r\n * or an array of String and Number objects that serve as a whitelist for\r\n * selecting the properties of the value object to be included in the JSON string.\r\n * If this value is null or not provided, all properties of the object are\r\n * included in the resulting JSON string.\r\n *\r\n * @param {number | string} [space]\r\n * A String or Number object that's used to insert white space into the output\r\n * JSON string for readability purposes. If this is a Number, it indicates the\r\n * number of space characters to use as white space; this number is capped at 10\r\n * if it's larger than that. Values less than 1 indicate that no space should be\r\n * used. If this is a String, the string (or the first 10 characters of the string,\r\n * if it's longer than that) is used as white space. If this parameter is not\r\n * provided (or is null), no white space is used.\r\n *\r\n * @returns {string | undefined} Returns the string representation of the JSON object.\r\n */\r\nexport function stringify(value, replacer, space) {\r\n  // clear stack\r\n  stack = [];\r\n  path = [];\r\n\r\n  let _value = (typeof replacer === 'function')\r\n      ? replacer.call({'': value}, '', value)\r\n      : value;\r\n\r\n  let _space; // undefined by default\r\n  if (typeof space === 'number') {\r\n    if (space > 10) {\r\n      _space = repeat(' ', 10);\r\n    }\r\n    else if (space >= 1) {\r\n      _space = repeat(' ', space);\r\n    }\r\n    // else ignore\r\n  }\r\n  else if (typeof space === 'string' && space !== '') {\r\n    _space = space;\r\n  }\r\n\r\n  return stringifyValue(_value, replacer, _space, '');\r\n}\r\n\r\n/**\r\n * Stringify a value\r\n * @param {*} value\r\n * @param {function | Array.<string | number>} [replacer]\r\n * @param {string} [space]\r\n * @param {string} [indent]\r\n * @return {string | undefined}\r\n */\r\nfunction stringifyValue(value, replacer, space, indent) {\r\n  // boolean\r\n  if (value === true || value === false || value instanceof Boolean) {\r\n    return value + '';\r\n  }\r\n\r\n  // null\r\n  if (value === null) {\r\n    return 'null';\r\n  }\r\n\r\n  // number\r\n  if (typeof value === 'number' || value instanceof Number) {\r\n    if (isNaN(value) || !isFinite(value)) {\r\n      return 'null';\r\n    }\r\n    return value + '';\r\n  }\r\n\r\n  // lossless number, the secret ingredient :)\r\n  if (value && value.isLosslessNumber) {\r\n    return value.value;\r\n  }\r\n\r\n  // string\r\n  if (typeof value === 'string' || value instanceof String) {\r\n    let escaped = '';\r\n\r\n    for (let i = 0; i < value.length; i++) {\r\n      let c = value[i];\r\n      escaped += CONTROL_CHARACTERS[c] || c;\r\n    }\r\n\r\n    return '\"' + escaped + '\"';\r\n  }\r\n\r\n  // date\r\n  if (value instanceof Date) {\r\n    return '\"' + value.toISOString() + '\"';\r\n  }\r\n\r\n  // array\r\n  if (Array.isArray(value)) {\r\n    return stringifyArray(value, replacer, space, indent);\r\n  }\r\n\r\n  // object (test lastly!)\r\n  if (value && typeof value === 'object') {\r\n    return stringifyObject(value, replacer, space, indent);\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Stringify an array\r\n * @param {Array} array\r\n * @param {function | Array.<string | number>} [replacer]\r\n * @param {string} [space]\r\n * @param {string} [indent]\r\n * @return {string}\r\n */\r\nfunction stringifyArray(array, replacer, space, indent) {\r\n  let childIndent = space ? (indent + space) : undefined;\r\n  let str = space ? '[\\n' : '[';\r\n\r\n  // check for circular reference\r\n  if (isCircular(array)) {\r\n    return stringifyCircular(array, replacer, space, indent);\r\n  }\r\n\r\n  // add this array to the stack\r\n  const stackIndex = stack.length;\r\n  stack[stackIndex] = array;\r\n\r\n  for (let i = 0; i < array.length; i++) {\r\n    let key = i + '';\r\n    let item = (typeof replacer === 'function')\r\n        ? replacer.call(array, key, array[i])\r\n        : array[i];\r\n\r\n    if (space) {\r\n      str += childIndent;\r\n    }\r\n\r\n    if (typeof item !== 'undefined' && typeof item !== 'function') {\r\n      path[stackIndex] = key;\r\n      str += stringifyValue(item, replacer, space, childIndent);\r\n    }\r\n    else {\r\n      str += 'null'\r\n    }\r\n\r\n    if (i < array.length - 1) {\r\n      str += space ? ',\\n' : ',';\r\n    }\r\n  }\r\n\r\n  // remove current entry from the stack\r\n  stack.length = stackIndex;\r\n  path.length = stackIndex;\r\n\r\n  str += space ? ('\\n' + indent + ']') : ']';\r\n  return str;\r\n}\r\n\r\n/**\r\n * Stringify an object\r\n * @param {Object} object\r\n * @param {function | Array.<string | number>} [replacer]\r\n * @param {string} [space]\r\n * @param {string} [indent]\r\n * @return {string}\r\n */\r\nfunction stringifyObject(object, replacer, space, indent) {\r\n  let childIndent = space ? (indent + space) : undefined;\r\n  let first = true;\r\n  let str = space ? '{\\n' : '{';\r\n\r\n  if (typeof object.toJSON === 'function') {\r\n    return stringify(object.toJSON(), replacer, space);\r\n  }\r\n\r\n  // check for circular reference\r\n  if (isCircular(object)) {\r\n    return stringifyCircular(object, replacer, space, indent);\r\n  }\r\n\r\n  // add this object to the stack\r\n  const stackIndex = stack.length;\r\n  stack[stackIndex] = object;\r\n\r\n  for (let key in object) {\r\n    if (object.hasOwnProperty(key)) {\r\n      let value = (typeof replacer === 'function')\r\n          ? replacer.call(object, key, object[key])\r\n          : object[key];\r\n\r\n      if (includeProperty(key, value, replacer)) {\r\n        if (first) {\r\n          first = false;\r\n        }\r\n        else {\r\n          str += space ? ',\\n' : ',';\r\n        }\r\n\r\n        str += space\r\n          ? (childIndent + '\"' + key + '\": ')\r\n          : ('\"' + key + '\":');\r\n\r\n        path[stackIndex] = key;\r\n        str += stringifyValue(value, replacer, space, childIndent);\r\n      }\r\n    }\r\n  }\r\n\r\n  // remove current entry from the stack\r\n  stack.length = stackIndex;\r\n  path.length = stackIndex;\r\n\r\n  str += space ? ('\\n' + indent + '}') : '}';\r\n  return str;\r\n}\r\n\r\n/**\r\n * Test whether an object or array is a circular reference\r\n * @param {Object | Array} value\r\n * @return {boolean}\r\n */\r\nfunction isCircular(value) {\r\n  return stack.indexOf(value) !== -1;\r\n}\r\n\r\n/**\r\n * Stringify a circular reference\r\n * @param {Object | Array} value\r\n * @param {function | Array.<string | number>} [replacer]\r\n * @param {string} [space]\r\n * @param {string} [indent]\r\n * @return {string}\r\n */\r\nfunction stringifyCircular (value, replacer, space, indent) {\r\n  if (!config().circularRefs) {\r\n    throw new Error('Circular reference at \"' + stringifyPointer(path) + '\"');\r\n  }\r\n\r\n  let pathIndex = stack.indexOf(value);\r\n\r\n  let circular = {\r\n    $ref: stringifyPointer(path.slice(0, pathIndex))\r\n  };\r\n\r\n  return stringifyObject(circular, replacer, space, indent);\r\n}\r\n\r\n/**\r\n * Test whether to include a property in a stringified object or not.\r\n * @param {string} key\r\n * @param {*} value\r\n * @param {function(key: string, value: *) | Array<string | number>} [replacer]\r\n * @return {boolean}\r\n */\r\nfunction includeProperty (key, value, replacer) {\r\n  return typeof value !== 'undefined'\r\n      && typeof value !== 'function'\r\n      && (!Array.isArray(replacer) || contains(replacer, key));\r\n}\r\n\r\n/**\r\n * Check whether an array contains some value.\r\n * Uses a non-strict comparison, so contains([1,2,3], '2') returns true\r\n * @param {Array} array\r\n * @param {*} value\r\n * @return {boolean}\r\n */\r\nfunction contains(array, value) {\r\n  for (let i = 0; i < array.length; i++) {\r\n    if (array[i] == value) { // non-strict equality check!\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Repeat a string a number of times.\r\n * Simple linear solution, we only need up to 10 iterations in practice\r\n * @param {string} text\r\n * @param {number} times\r\n * @return {string}\r\n */\r\nfunction repeat (text, times) {\r\n  let res = '';\r\n  while (times-- > 0) {\r\n    res += text;\r\n  }\r\n  return res;\r\n}\r\n"],"names":["config","options","undefined","circularRefs","valueToString","value","test","isValidNumber","Error","getDigits","length","isNaN","isFinite","valueOf","replace","reviveValue","context","key","reviver","Array","isArray","call","array","revived","i","reviveArray","isLosslessNumber","object","hasOwnProperty","reviveObject","escape","str","encodeURIComponent","unescape","decodeURIComponent","stringify","map","join","next","jsonText","charAt","index","getToken","TOKENTYPE","NULL","c","DELIMITERS","DELIMITER","isDigit","NUMBER","createSyntaxError","isAlpha","UNKNOWN","token","SYMBOL","STRING","unescaped","ESCAPE_CHARACTERS","hex","u","isHex","String","fromCharCode","parseInt","message","error","SyntaxError","parseObject","stackIndex","stack","tokenType","$ref","Object","keys","isCircular","pointerPath","pointer","split","shift","pop","parsePointer","path","parseCircular","push","number","LosslessNumber","parseEnd","parseSymbol","parseNumber","parseString","parseArray","replacer","space","_value","_space","repeat","stringifyValue","indent","Boolean","Number","escaped","CONTROL_CHARACTERS","Date","toISOString","childIndent","stringifyCircular","item","stringifyArray","stringifyObject","first","toJSON","contains","includeProperty","indexOf","stringifyPointer","pathIndex","slice","text","times","res","type","parseFloat","this","digits","Math","abs","MIN_VALUE","containsOnlyZeros","json","revive"],"mappings":"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"}